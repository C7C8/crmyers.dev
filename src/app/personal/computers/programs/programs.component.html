<h1>Programs</h1>

<p>I've worked on a lot of different projects over the past ~5 years or so, most of which were made in the course of
    self-education or a simple desire to mess around a bit. Most everything can be found on my GitHub profile at
<a href="https://github.com/c7c8">github.com/C7C8</a>, and all have free software licenses (typically GPLv3, or MIT in
a few cases). That means that you're more than welcome to use my code for anything you like &mdash; in fact I encourage
it!</p>

<p>In the case of the GPL'd code I do ask that you share modifications or code you make using my code in the same way,
under the same license (it's part of the GPL). This may seem strict, but in my view I wouldn't be where I am today
without plenty of open source projects to guide me along, so I prefer to give back and make sure that indirect products
of my work are similarly open to learn from.</p>

<div class="accordion-wrapper">
    <mat-accordion [multi]="true">
        <app-program name="Rust-Brainfuck"
                     [tags]="['Rust']"
                     year="2019"
                     github="c7c8/rust-brainfuck">
            <p><b>Rust Brainfuck</b> is a simple, 88-line Brainfuck interpreter written in Rust as a get-to-know-the-language
            exercise. I've made it available because it is, after all, a working interpreter. I haven't gotten <em>too</em>
            far with Rust just yet, but one day I hope to!</p>

            <p>If you aren't familiar with it, <a href="en.wikipedia.org/wiki/Brainfuck">Brainfuck</a> is something
            of a joke language with only 8 commands and a data pointer. You can move the data pointer, increment/decrement
            the data at the pointer, print the data, overwrite it with user input, execute simple conditionals, and... that's
            about it! Due to the simplicity of the language it fits well into a stack model, so every brainfuck interpreter
            ever is extraordinarily simple. This one has a little bit of extra error handling and work done to allow integer
            wraparound (which if I recall correctly would otherwise be a problem), but otherwise it falls in line with all
            other interpreters.</p>
        </app-program>

        <app-program name="WIP: Deuterium Knowledge Engine"
                     [tags]="['WIP', 'Java', 'GUI']"
                     year="2019"
                     github="c7c8/deuterium">
            <p><b><em>Warning!</em> Big text dump incoming!</b></p>

            <p>
                <b>Deuterium</b> is a project I started toying around with a long time ago but only started putting into real
                code a few months ago. The idea is to create a knowledge management engine &mdash; something akin to a very
                sophisticated mind map &amp; with elements of simple graph theory to allow organization of both what is
                already known and what has not yet been learned. It's based on dependency graph model, wherein pieces of
                knowledge have both dependencies and dependents, with those links forming edges of a directed graph. When
                knowledge is modeled like this, it makes it easier to group information together or sort it using simple
                algorithms or network analysis techniques. It also fits well into the model of a person researching
                something who finds something else they want to check on later, or who realizes they need to learn
                something else in order to understand their current goal.
            </p>

            <p>
                For example, suppose you wanted to learn about atoms. To start you might want to understand what the
                properties of mass are, so you note that you need to learn some classical physics. Then, you realize
                that you should probably brush up on your calculus so you can do some of the more complex calculations.
                After realizing you've found yourself in a physics rabbit hole, you return to atoms and note down that
                you should read up on electrons, protons, and neutrons. In the process you happen across electrical charge,
                so you note that down too. Electric fields can result in forces, you note, so that takes you back to
                classical physics.
            </p>

            <p>
                The problem you've encountered is that there are an incredible amount of things to learn but it might be
                tough to know where to start, or what to read up on if you need a refresher on something. The program I'm
                building, Deuterium, is designed to tackle that problem. Each of the subjects from above would get its
                own vertex on the graph, and the relationships between them would be modeled as directed edges. Then if
                you wanted to know what you should read up on (and in what order), you could select one vertex and perform
                a simple topological sort. If, much later, you amassed a huge network of subjects and knowledge and attached
                notes, you could even perform a network analysis to group pieces of information into logical subjects.
            </p>

            <p>
                Deuterium isn't complete yet and it likely won't be for a while, but when it's finished it will ideally
                have a full, intuitive and modern looking UI, plus numerous features to assist in the learning and
                researching .
            </p>
        </app-program>

        <app-program name="CS 3733 API Update Checker"
                     [tags]="['Java', 'Network']"
                     year="2018"
                     github="c7c8/SoftEng-API-UpdateChecker">
            The <b>CS 3733 API Update Checker</b> is a simple Java library for teams of students taking Professor Wong's
            Software Engineering class at Worcester Polytechnic Institute. As part of the class, teams create and share Java
            libraries for other teams to integrate into their projects. I built a website that hosts a Maven repository
            containing all of these APIs, which makes it easier for teams to share and update their libraries. This library
            simply checks the server to see if an update for a given API is available, for instance to help a team prompt
            the user into updating.
        </app-program>

        <app-program name="PDP-1186"
                     [tags]="['C++', 'WIP']"
                     year="2018"
                     github="c7c8/pdp-1186">
           <b>PDP-1186</b> is a long-since abandoned project to create an emulator for an old minicomputer called the
            PDP-11. It was part self-education (I <em>really</em> like systems programming), part hack-a-day, part
            old-computer enthusiasm &mdash; the PDP-11 helped inspire crucial elements of the x86 architecture, and was
            the first to run UNIX v6.

            I worked on the project during a hack-a-day hosted at my university and got some work done on it
            shortly afterwards, but haven't picked it up since. I likely won't in the future considering that
            <a href="www.de.ioccc.org/2018/mills/hint.html">in 2018 someone won the IOCCC Best in Show for
            a very tiny PDP-7 emulator</a>.
        </app-program>

        <app-program name="MSP430 Tetris"
                     [tags]="['C', 'Embedded']"
                     year="2018"
                     github="c7c8/msp430-tetris"
                     video="/assets/personal/vid/msp430-tetris.m4v">
            <p>
                In 2018 I took a class on embedded computing, which was really just a class on learning about one
                specific device instead of generals of embedded computing. Since it wasn't very interesting I ported
                Tetris over to the class microprocessor in my free time!
            </p>

            <p>
                It uses the LCD included with the course kit and a board we were provided with as a base (you can
                see it underneath in the video, it has a buzzer and a keybad attached to it). The keypad keys
                2, 4, 5, and 6 control rotation, left, down, and right, respectively, while the original Tetris
                tune plays in the background (although at the time the video was taken, I hadn't fixed it properly
                so the notes are more than a little distorted!).
            </p>

            <p>
                Major credit to <a href="github.com/brenns10">Stephen Brennan</a> for his terminal
                <a href="github.com/brenns10/tetris">Tetris implementation in C</a>; his work underpins the
                port I made, and without it this project would not have gotten off the ground. Everything else
                &mdash; the music, the keyboard controls, timing and interrupts, etc. &mdash; is mine. Unfortunately
                I couldn't include the display or keypad driver code since they belong to Worcester Poyltechnic Institute.
            </p>
        </app-program>

        <app-program name="CS 3733 Hospital Navigator"
                     [tags]="['Java', 'GUI', 'College']"
                     year="2017"
                     github="c7c8/CS3733-HospitalProject"
                     image="/assets/personal/img/hospital-navigator.png">
            <p>
                <b>The Hospital Navigator</b> project was constructed by a team of 9 students at Worcester Polytechnic
                Institute, of which I had the position of lead developer. The application is designed to provide
                visitors to Brigham and Women's Faulkner Hospital directions from set locations ("kiosks") to any
                other location in the building. Users can search for doctors on the main menu, or they can simply
                click on locations on the map view, and they'll be given visual and textual directions to get where
                they want. Other features include a "fire exit" mode, which directs users to the nearest exit, a
                map editor, multiple pathfinding modes, and the option to use only stairs or only elevators.
            </p>
        </app-program>

        <app-program name="Pathviz 2"
                     [tags]="['C++', 'GUI', 'High School']"
                     year="2016"
                     github="c7c8/Pathviz-2"
                     image="/assets/personal/img/home-carousel/pathviz2.png">
            <p>
                <b>Pathviz 2</b> is the <span matTooltip="0-ordered!">third iteration</span> of a pathfinding
                algorithm visualizer I built in my junior year of high school. It's designed to show how two common
                pathfinding algorithms, A* and Dijkstra's, are able to efficiently find the shortest path to the goal.
                The colorscheme (yes, I know it's insanely grating on the eyes) uses blue for empty space, red for
                explored areas, green for areas on the open list, orange for barriers, and dark green for the found
                path. You can choose between the two algorithms (plus three different heuristics for A*) and a simple
                depth-first maze generator.
            </p>

            <p>
                On the technical side, the program is written in C++ using SDL2 for graphics and input. The very
                first version of the program &mdash; version 0 &mdash; was also written in C++, but used a homebrew
                terminal graphics library that, while effective, didn't allow for mouse input. The second version
                straight-up didn't work, so here we are on the third version, which is much more nicely architected
                and easy to use.
            </p>
        </app-program>

        <app-program name="N-Ball Simulator"
                     [tags]="['C++', 'GUI', 'High School']"
                     year="2015"
                     github="nball-sim"
                     image="/assets/personal/img/home-carousel/nball-sim.png">
            <p>
                <b>N-Ball Simulator</b> is the second version of a Newtonian gravity simulator I built, at first for fun,
                but then later adapted for my senior year physics project in high school. The simulator allows you to
                launch balls in a 2D plane that have mass and velocity. Every object is attracted to every other object
                according to Newton's law of universal gravitation. Objects leave trails behind them that correspond
                to where they've been (longer means faster, too), and the simulation draws a red dot to show the barycenter,
                or center of mass for all objects in the simulation. Under the hood it uses velocity Verlet integration,
                which allows it to more or less conserve energy and stay accurate over time.
            </p>
            <p>
                After initial development in 2015, I adapted it for use in a physics project centered on finding a
                relationship between the number of objects, the total mass of the simulation, and the amount of time it
                takes for all objects to coalesce into one &mdash; an attempt to model the formation of stars or planets.
                I collected some 40,000 data points from the simulation and determined there was as the very least an
                inverse-square relationship between mass (or as written in my report, number of objects in the simulation)
                and coalescence time, and that if a simulation had too much kinetic energy and not enough mass it simply
                wouldn't coalesce.
            </p>
        </app-program>
    </mat-accordion>
</div>
